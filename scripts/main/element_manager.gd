## ElementManager
# Autoloaded node that controls all necessary functions to modifiy, create, fuse, and other actions to Elements!
# Can be called anywhere on the game, but mostly used in UI actions and events 
extends Node

const CONTROL_SLOT_SCENE : PackedScene = preload('res://components/interface/control_slot.tscn')
const DRAGGABLE_OBJECT_SCENE : PackedScene = preload("res://components/interface/object.tscn")
const COMBINATIONS : Dictionary = {
	"fire": {
		"fire": "conflagration",
		"water": "steam",
		"air": 'lightning',
		'earth': 'metal',
		'cursed': 'scorch'
	},
	'water': {
		'water': 'ice',
		'fire': 'steam',
		'earth': 'oil',
		'air':  'rain',
		'cursed': 'abyss'
	},
	'air': {
		'air': 'turbulence',
		'water': 'rain',
		'fire': 'lightning',
		'earth': 'dust',
		'cursed': 'miasma'
	},
	'earth': {
		'earth': 'mountain',
		'fire': 'metal',
		'water': 'oil',
		'air': 'dust',
		'cursed': 'rot'
	},
	'cursed': {
		'cursed': 'profaned'
	}
}

var active_registers : Array[ElementRegister]
var element_textures : Dictionary = {}

func _ready() -> void:
	var temp_dos : DraggableObjectSprite = DraggableObjectSprite.new()
	element_textures = temp_dos.load_all_sprites()
	temp_dos.queue_free()

#region Element Manipulation
## Returns an element ID from two other IDs by checking the COMBINATIONS dictionary
func combine(first_element, second_element) -> String: 
	if !COMBINATIONS.has(first_element) or !COMBINATIONS.has(second_element): return '' #! INVALID ELEMENTS
	if !COMBINATIONS[first_element].has(second_element): return ' '#! No combination found
	var result = COMBINATIONS[first_element][second_element]
	if result: return result
	else: return ''

## Recieves an ID of an essence generated by the combine function, returns the new_element
func fuse(combination_id : String, add_directly : bool = false) -> Element: 
	var combined_essence : Element = Element.new()
	combined_essence.element_type = 1
	combined_essence.element_id = combination_id
	if add_directly: add_element(combined_essence)
	return combined_essence

## Generates a draggable object which can be located on containers in screen and attached into slots
func generate_object( 
		root_slot : Slot,
		source_object : bool,
		element : Element
	) -> DraggableObject:
	var object = DRAGGABLE_OBJECT_SCENE.instantiate()
	object.active_slot = root_slot
	object.home_slot = root_slot ## Return to this node position if something goes wrong or the screen which it was positioned gets closed
	object.source_object = source_object ## Instead of moving the object, creates another one
	object.element = element
	root_slot.add_child(object)
	
	if element_textures.has(element.element_id): object.object_element_sprite.set_texture(element_textures[element.element_id])
	else: push_warning(element, ' | Element sprite not found!')
	return object

## Generates an Element resource from an ID and type
func generate_element( 
		type : int, ## [0: element, 1: essence]
		id : String, ## [ex.: 'fire', 'water'] 
	) -> Element:
	var new_element = Element.new()
	new_element.element_type = type
	new_element.element_id = id
	add_child(new_element)
	return new_element

## Query an element to see if it already exists on the runtime array
func query_element(id : String) -> bool:
	for reg in active_registers: if id == reg.element.element_id: return true
	return false

## Add to an existing element or a new one
func add_element(
		element : Element,
		element_type : int = 1,
		quantity : int = 1,
		container : Container = UI.HUD._request_container(element.element_type)
	) -> ElementRegister:
	assert(container)
	var register : ElementRegister
	var element_registered : bool = query_element(element.element_id)
	
	if element_registered: #? Element already exists on register
		register.quantity += quantity
		return register
	else: #? New element
		register = ElementRegister.new()
		register.element = element
		register.quantity = quantity
		register.element.element_type = element_type
		
		var control_slot : ControlSlot = _set_control_slot(register)
		container.add_child(control_slot)
		control_slot.slot.slot_type = element_type
		register.control_slot = control_slot.get_path()
		register.slot = control_slot.slot.get_path()
		
		var object = _set_object(control_slot, element)
		active_registers.append(register)
		return register
#endregion

#region Integration
## Create and define ControlSlot
func _set_control_slot(reg : ElementRegister) -> ControlSlot:
	var control_slot : ControlSlot = CONTROL_SLOT_SCENE.instantiate()
	control_slot.set_name('{0}{1}'.format({0: reg.element.element_id.capitalize(), 1: 'Container'}))
	control_slot.slot_register = reg
	return control_slot

## Create and define DraggableObject
func _set_object(c_slot : ControlSlot, element : Element) -> DraggableObject:
	var new_object : DraggableObject = generate_object(c_slot.slot, true, element)
	new_object.set_name('{0}{1}'.format({0: element.element_id.capitalize(), 1: 'Object'}))
	c_slot.slot.add_child(new_object)
	return new_object
#endregion
